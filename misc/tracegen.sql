/*
    cmd/trace-loader/main.go loads a table named `trace_stg` with json
    objects generated by the Open Telemetry tracegen tool
    https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/tracegen

    this sql processes the json objects from the `trace_stg` tool into the tracing schema
*/

set search_path to prom_trace;

-- load the attribute_key and attribute tables with resource and span attributes
do $do$
declare
    _attr record;
begin
    for _attr in
    (
        select distinct
          j->>'key' as key
        , jsonb_path_query_first(j, '$.value.*') as value
        , s.attribute_type
        from
        (
            values
            (resource_attribute_type(), '$.resource.attributes[*]'),
            (span_attribute_type(), '$.instrumentationLibrarySpans[*].spans[*].attributes[*]')
        ) s(attribute_type, path)
        cross join
        (
            select jsonb_path_query(t.trace, '$.resourceSpans[*]') as trace
            from public.trace_stg t
        ) t
        cross join lateral jsonb_path_query(
        t.trace,
        s.path::jsonpath
        ) j
    )
    loop
        perform put_attribute_key(_attr.key, _attr.attribute_type);
        perform put_attribute(_attr.key, _attr.value, _attr.attribute_type);
    end loop;
end;
$do$;

select * from attribute_key;
select * from attribute;

-- load the span_name table
insert into span_name (name)
select jsonb_path_query(t.trace, '$.resourceSpans[*].instrumentationLibrarySpans[*].spans[*]')->>'name'
from public.trace_stg t
on conflict (name) do nothing
;

select * from span_name;

-- load the schema_url table (none found in sample data)
insert into schema_url (url)
select jsonb_path_query(t.trace, '$.resourceSpans[*].instrumentationLibrarySpans[*].schemaUrl')
from public.trace_stg t
on conflict (url) do nothing
;

insert into schema_url (url) values ('https://schema.instlib.example');

select * from schema_url;

-- load the instrumentation_library table
insert into instrumentation_library (name, version, schema_url_id)
select distinct
  i->>'name'
, coalesce(i->>'version', '1.2.3')
, (select id from schema_url limit 1) -- none in the sample data
from public.trace_stg t
cross join lateral jsonb_path_query(t.trace, '$.resourceSpans[*].instrumentationLibrarySpans[*].instrumentationLibrary') i
where i ? 'name'
on conflict (name, version, schema_url_id) do nothing
;

select * from instrumentation_library;

insert into span
(
    trace_id,
    span_id,
    trace_state,
    parent_span_id,
    name_id,
    span_kind,
    start_time,
    end_time,
    span_attributes,
    dropped_attributes_count,
    event_time,
    dropped_events_count,
    dropped_link_count,
    status_code,
    status_message,
    instrumentation_library_id,
    resource_attributes,
    resource_dropped_attributes_count,
    resource_schema_url_id
)
select
  (s->>'traceId')::trace_id as trace_id
, ('x' || lpad(s->>'spanId', 16, '0'))::bit(64)::bigint as span_id -- convert hex string to bigint
, null as trace_state
, case when s->>'parentSpanId' = '' then null else ('x' || lpad(s->>'parentSpanId', 16, '0'))::bit(64)::bigint end as parent_span_id -- convert hex string to bigint
, n.id as span_name_id
, (case s->>'kind'
    when 'SPAN_KIND_UNSPECIFIED' then 'UNSPECIFIED'
    when 'SPAN_KIND_INTERNAL' then 'INTERNAL'
    when 'SPAN_KIND_SERVER' then 'SERVER'
    when 'SPAN_KIND_CLIENT' then 'CLIENT'
    when 'SPAN_KIND_PRODUCER' then 'PRODUCER'
    when 'SPAN_KIND_CONSUMER' then 'CONSUMER'
  end)::span_kind as span_kind
, 'epoch'::timestamptz + ((s->>'startTimeUnixNano')::bigint / 1000000000.0 * interval '1 second') as start_time -- convert epoch nanos to timestamptz
, 'epoch'::timestamptz + ((s->>'endTimeUnixNano')::bigint / 1000000000.0 * interval '1 second') as end_time -- convert epoch nanos to timestamptz
, sa.span_attributes::attribute_map as span_attributes
, coalesce((s->>'droppedAttributesCount')::int, 0) as dropped_attributes_count
, tstzrange('infinity', 'infinity', '()') as event_time
, coalesce((s->>'droppedEventsCount')::int, 0) as dropped_events_count
, coalesce((s->>'droppedLinksCount')::int, 0) as dropped_links_count
, (case s->'status'->>'code'
    when 'STATUS_CODE_UNSET' then 'UNSET'
    when 'STATUS_CODE_OK' then 'OK'
    when 'STATUS_CODE_ERROR' then 'ERROR'
  end)::status_code status_code
, s->'status'->>'message' as status_message
, il.id as instrumentation_library_id
, ra.resource_attributes::attribute_map as resource_attributes
, coalesce((r->'resource'->>'droppedAttributesCount')::int, 0) as resource_dropped_attributes_count
, u2.id as resource_schema_url
from public.trace_stg t
cross join lateral jsonb_path_query(t.trace, '$.resourceSpans[*]') r
cross join lateral jsonb_path_query(r, '$.instrumentationLibrarySpans[*]') i
cross join lateral jsonb_path_query(i, '$.spans[*]') s
left outer join lateral
(
    select jsonb_object_agg(ak.id, a.id) as span_attributes
    from attribute a
    inner join attribute_key ak on a.key = ak.key
    inner join
    (
        select
          x->>'key' as key
        , jsonb_path_query_first(x, '$.value.*') as value
        from jsonb_path_query(s, '$.attributes[*]') x
    ) x on (a.key = x.key and a.value = x.value)
    where is_span_attribute_type(a.attribute_type)
    and is_span_attribute_type(ak.attribute_type)
) sa on (true)
left outer join lateral
(
    select jsonb_object_agg(ak.id, a.id) as resource_attributes
    from attribute a
    inner join attribute_key ak on a.key = ak.key
    inner join
    (
        select
          x->>'key' as key
        , jsonb_path_query_first(x, '$.value.*') as value
        from jsonb_path_query(r, '$.resource.attributes[*]') x
    ) x on (a.key = x.key and a.value = x.value)
    where is_resource_attribute_type(a.attribute_type)
    and is_resource_attribute_type(ak.attribute_type)
) ra on (true)
left outer join span_name n on (n.name = s->>'name')
left outer join schema_url u on (u.url = coalesce(i->>'schemaUrl', 'https://schema.instlib.example'))
left outer join instrumentation_library il on
(
    il.name = i->'instrumentationLibrary'->>'name' and
    il.version = coalesce(i->'instrumentationLibrary'->>'version', '1.2.3') and
    il.schema_url_id = u.id
)
left outer join schema_url u2 on (u2.url = coalesce(r->>'schemaUrl', 'https://schema.instlib.example'))
;

-- trace table
-- array of node paths
with recursive x as
(
    select
      trace_id
    , span_id as root_span_id
    , 1 as span_count
    , span_id
    , start_time
    , end_time
    , jsonb_build_array(span_id) as span_tree
    from span
    where parent_span_id is null
    union all
    select
      x.trace_id
    , x.span_id as root_span_id
    , x.span_count + 1 as span_count
    , s.span_id
    , least(x.start_time, s.start_time) as start_time
    , greatest(x.end_time, s.end_time) as end_time
    , x.span_tree || jsonb_build_array(s.span_id) as span_tree
    from x
    inner join span s on x.trace_id = s.trace_id
    and x.span_id = s.parent_span_id
)
insert into trace (id, root_span_id, span_count, span_time_range, event_time_range, span_tree)
select
  x.trace_id
, max(x.root_span_id)
, max(x.span_count)
, tstzrange(min(x.start_time), max(x.end_time), '[)') as span_time_range
, tstzrange('infinity', 'infinity', '()') as event_time_range
, jsonb_agg(x.span_tree) as span_tree
from x
group by x.trace_id
;



/*
-- attempt at an alternate tree representation
with recursive x as
(
    select
      trace_id
    , span_id
    , span_id as root_span_id
    , 1 as span_count
    , start_time
    , end_time
    , 1 as lvl
    from span s
    where parent_span_id is null
    union all
    select
      x.trace_id
    , s.span_id
    , x.span_id as root_span_id
    , x.span_count + 1 as span_count
    , least(s.start_time, x.start_time) as start_time
    , greatest(s.end_time, x.end_time) as end_time
    , x.lvl + 1 as lvl
    from x
    inner join span s on x.trace_id = s.trace_id
    and x.span_id = s.parent_span_id
)
select
  trace_id
, max(x.root_span_id) as root_span_id
, max(span_count) as span
,
from
(
    select
      trace_id
    , lvl
    , max(root_span_id) as root_span_id
    , max(span_count) as span_count
    , min(start_time) as start_time
    , max(end_time) as end_time
    , jsonb_build_array(span_id) as span_tree
    from x
    group by trace_id, lvl
) x
group by trace_id
;
*/